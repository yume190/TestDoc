{"metadata":{"title":"Incremental Adoption"},"schemaVersion":{"major":0,"patch":0,"minor":3},"kind":"article","sections":[],"abstract":[{"type":"text","text":"Learn how you can introduce Swift concurrency features into your project"},{"text":" ","type":"text"},{"type":"text","text":"incrementally."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.migration.6\/documentation\/Swift-6-Concurrency-Migration-Guide\/IncrementalAdoption"},"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Migrating projects towards the Swift 6 language mode is usually done in stages.","type":"text"},{"text":" ","type":"text"},{"text":"In fact, many projects began the process before Swift 6 was even available.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You can continue to introduce concurrency features "},{"inlineContent":[{"type":"text","text":"gradually"}],"type":"emphasis"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"addressing any problems that come up along the way.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This allows you to make incremental progress without disrupting the"},{"text":" ","type":"text"},{"type":"text","text":"entire project."}]},{"inlineContent":[{"text":"Swift includes a number of language features and standard library APIs to help","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"make incremental adoption easier."}],"type":"paragraph"},{"type":"heading","anchor":"Wrapping-Callback-Based-Functions","text":"Wrapping Callback-Based Functions","level":2},{"type":"paragraph","inlineContent":[{"text":"APIs that accept and invoke a single function on completion are an extremely","type":"text"},{"type":"text","text":" "},{"text":"common pattern in Swift.","type":"text"},{"text":" ","type":"text"},{"text":"It’s possible to make a version of such a function that is usable directly from","type":"text"},{"type":"text","text":" "},{"text":"an asynchronous context.","type":"text"}]},{"code":["func updateStyle(backgroundColor: ColorComponents, completionHandler: @escaping () -> Void) {","    \/\/ ...","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is an example of a function that informs a client its work is complete"},{"text":" ","type":"text"},{"type":"text","text":"using a callback."},{"text":" ","type":"text"},{"text":"There is no way for a caller to determine when or on what thread the callback","type":"text"},{"type":"text","text":" "},{"text":"will be invoked without consulting documentation.","type":"text"}]},{"inlineContent":[{"type":"text","text":"You can wrap this function up into an asynchronous version using"},{"type":"text","text":" "},{"inlineContent":[{"text":"continuations","type":"text"}],"type":"emphasis"},{"text":".","type":"text"}],"type":"paragraph"},{"code":["func updateStyle(backgroundColor: ColorComponents) async {","    withCheckedContinuation { continuation in","        updateStyle(backgroundColor: backgroundColor) {","            continuation.resume()","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"With an asynchronous version, there is no longer any ambiguity.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"After the function has completed, execution will always resume in the same"},{"type":"text","text":" "},{"text":"context it was started in.","type":"text"}]},{"code":["await updateStyle(backgroundColor: color)","\/\/ style has been updated"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"withCheckedContinuation"},{"text":" function is one of a ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/concurrency#continuations"},{"type":"text","text":" that exist to make interfacing non-async and async code possible."}],"type":"paragraph"},{"style":"note","type":"aside","content":[{"inlineContent":[{"type":"text","text":"Introducing asynchronous code into a project can surface data isolation"},{"type":"text","text":" "},{"text":"checking violations. To understand and address these, see ","type":"text"},{"isActive":true,"identifier":"commonproblems#Crossing-Isolation-Boundaries","type":"reference"}],"type":"paragraph"}],"name":"Note"},{"anchor":"Dynamic-Isolation","type":"heading","level":2,"text":"Dynamic Isolation"},{"inlineContent":[{"type":"text","text":"Expressing the isolation of your program statically, using annotations and"},{"type":"text","text":" "},{"type":"text","text":"other language constructs, is both powerful and concise."},{"text":" ","type":"text"},{"type":"text","text":"But, it can be difficult to introduce static isolation without updating"},{"type":"text","text":" "},{"type":"text","text":"all dependencies simultaneously."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Dynamic isolation provides runtime mechanisms you can use as a fallback for"},{"text":" ","type":"text"},{"type":"text","text":"describing data isolation."},{"text":" ","type":"text"},{"text":"It can be an essential tool for interfacing a Swift 6 component","type":"text"},{"text":" ","type":"text"},{"text":"with another that has not yet been updated,","type":"text"},{"type":"text","text":" "},{"text":"even if these components are within the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"same","type":"text"}]},{"text":" module.","type":"text"}]},{"type":"heading","anchor":"Internal-Only-Isolation","level":3,"text":"Internal-Only Isolation"},{"type":"paragraph","inlineContent":[{"text":"Suppose you have determined that a reference type within your project can be","type":"text"},{"type":"text","text":" "},{"text":"best described with ","type":"text"},{"code":"MainActor","type":"codeVoice"},{"type":"text","text":" static isolation."}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","class WindowStyler {","    private var backgroundColor: ColorComponents","","    func applyStyle() {","        \/\/ ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This "},{"type":"codeVoice","code":"MainActor"},{"type":"text","text":" isolation may be "},{"type":"emphasis","inlineContent":[{"text":"logically","type":"text"}]},{"type":"text","text":" correct."},{"type":"text","text":" "},{"type":"text","text":"But, if this type is used in other unmigrated locations,"},{"text":" ","type":"text"},{"text":"adding static isolation here could require many additional changes.","type":"text"},{"type":"text","text":" "},{"text":"An alternative is to use dynamic isolation to help control the scope.","type":"text"}]},{"syntax":"swift","code":["class WindowStyler {","    @MainActor","    private var backgroundColor: ColorComponents","","    func applyStyle() {","        MainActor.assumeIsolated {","            \/\/ use and interact with other `MainActor` state","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"Here, the isolation has been internalized into the class.","type":"text"},{"text":" ","type":"text"},{"text":"This keeps any changes localized to the type, allowing you make","type":"text"},{"type":"text","text":" "},{"type":"text","text":"changes without affecting any clients of the type."}],"type":"paragraph"},{"inlineContent":[{"text":"However, a major disadvantage of this technique is the type’s true isolation","type":"text"},{"text":" ","type":"text"},{"text":"requirements remain invisible.","type":"text"},{"type":"text","text":" "},{"text":"There is no way for clients to determine if or how they should change based on","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"this public API."},{"text":" ","type":"text"},{"type":"text","text":"You should use this approach only as a temporary solution, and only when you"},{"type":"text","text":" "},{"type":"text","text":"have exhausted other options."}],"type":"paragraph"},{"text":"Usage-Only Isolation","type":"heading","anchor":"Usage-Only-Isolation","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"If it is impractical to contain isolation exclusively within a type, you can"},{"type":"text","text":" "},{"text":"instead expand the isolation to cover only its API usage.","type":"text"}]},{"inlineContent":[{"text":"To do this, first apply static isolation to the type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and then use dynamic isolation at any usage locations:"}],"type":"paragraph"},{"syntax":"swift","code":["@MainActor","class WindowStyler {","    \/\/ ...","}","","class UIStyler {","    @MainActor","    private let windowStyler: WindowStyler","    ","    func applyStyle() {","        MainActor.assumeIsolated {","            windowStyler.applyStyle()","        }","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Combining static and dynamic isolation can be a powerful tool to keep the"},{"text":" ","type":"text"},{"text":"scope of changes gradual.","type":"text"}]},{"text":"Missing Annotations","type":"heading","level":2,"anchor":"Missing-Annotations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Dynamic isolation gives you tools to express isolation at runtime."},{"text":" ","type":"text"},{"type":"text","text":"But, you may also find you need to describe other concurrency properties"},{"text":" ","type":"text"},{"type":"text","text":"that are missing from unmigrated modules."}]},{"anchor":"Unmarked-Sendable-Closures","level":3,"type":"heading","text":"Unmarked Sendable Closures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The sendability of a closure affects how the compiler infers isolation for its"},{"type":"text","text":" "},{"type":"text","text":"body."},{"text":" ","type":"text"},{"text":"A callback closure that actually does cross isolation boundaries but is","type":"text"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"missing"}]},{"type":"text","text":" a "},{"code":"Sendable","type":"codeVoice"},{"text":" annotation violates a critical invariant of the","type":"text"},{"type":"text","text":" "},{"text":"concurrency system.","type":"text"}]},{"code":["\/\/ definition within a pre-Swift 6 module","extension JPKJetPack {","    \/\/ Note the lack of a @Sendable annotation","    static func jetPackConfiguration(_ callback: @escaping () -> Void) {","        \/\/ Can potentially cross isolation domains","    }","}","","@MainActor","class PersonalTransportation {","    func configure() {","        JPKJetPack.jetPackConfiguration {","            \/\/ MainActor isolation will be inferred here","            self.applyConfiguration()","        }","    }","","    func applyConfiguration() {","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"jetPackConfiguration"},{"type":"text","text":" can invoke its closure in another isolation domain,"},{"type":"text","text":" "},{"type":"text","text":"it must be marked "},{"type":"codeVoice","code":"@Sendable"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"When an un-migrated module hasn’t yet done this, it will result in incorrect"},{"type":"text","text":" "},{"type":"text","text":"actor inference."},{"text":" ","type":"text"},{"type":"text","text":"This code will compile without issue but crash at runtime."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To workaround this, you can manually annotate the closure with "},{"type":"codeVoice","code":"@Sendable."},{"type":"text","text":" "},{"text":"This will prevent the compiler from inferring ","type":"text"},{"type":"codeVoice","code":"MainActor"},{"type":"text","text":" isolation."},{"type":"text","text":" "},{"type":"text","text":"Because the compiler now knows actor isolation could change,"},{"type":"text","text":" "},{"text":"it will require at await at the callsite.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","class PersonalTransportation {","    func configure() {","        JPKJetPack.jetPackConfiguration { @Sendable in","            \/\/ Sendable closures do not infer actor isolation,","            \/\/ making this context non-isolated","            await self.applyConfiguration()","        }","    }","","    func applyConfiguration() {","    }","}"]},{"text":"Backwards Compatibility","level":2,"type":"heading","anchor":"Backwards-Compatibility"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s important to keep in mind that static isolation, being part of the type"},{"type":"text","text":" "},{"type":"text","text":"system, affects your public API."},{"type":"text","text":" "},{"type":"text","text":"But, you can migrate your own modules in a way that improves their APIs for"},{"type":"text","text":" "},{"type":"text","text":"Swift 6 "},{"type":"emphasis","inlineContent":[{"text":"without","type":"text"}]},{"type":"text","text":" breaking any existing clients."}]},{"inlineContent":[{"text":"Suppose the ","type":"text"},{"type":"codeVoice","code":"WindowStyler"},{"text":" is public API.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"You have determined that it really should be "},{"code":"MainActor","type":"codeVoice"},{"text":"-isolated, but want to","type":"text"},{"type":"text","text":" "},{"text":"ensure backwards compatibility for clients.","type":"text"}],"type":"paragraph"},{"code":["@preconcurrency @MainActor","public class WindowStyler {","    \/\/ ...","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Using "},{"type":"codeVoice","code":"@preconcurrency"},{"text":" this way marks the isolation as conditional on the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"client module also having complete checking enabled."},{"text":" ","type":"text"},{"type":"text","text":"This preserves source compatibility with clients that have not yet begun"},{"text":" ","type":"text"},{"type":"text","text":"adopting Swift 6."}],"type":"paragraph"},{"type":"heading","level":2,"text":"Dependencies","anchor":"Dependencies"},{"inlineContent":[{"text":"Often, you aren’t in control of the modules you need to import as dependencies.","type":"text"},{"type":"text","text":" "},{"text":"If these modules have not yet adopted Swift 6, you may find yourself with","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"errors that are difficult or impossible to resolve."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"There are a number of different kinds of problems that result from using","type":"text"},{"type":"text","text":" "},{"type":"text","text":"unmigrated code."},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"@preconcurrency"},{"text":" annotation can help with many of these situations:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"overridingTitle":"Non-Sendable types","overridingTitleInlineContent":[{"text":"Non-Sendable types","type":"text"}],"type":"reference","identifier":"commonproblems#Crossing-Isolation-Boundaries","isActive":true}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Mismatches in "},{"type":"reference","isActive":true,"identifier":"commonproblems#Crossing-Isolation-Boundaries","overridingTitleInlineContent":[{"type":"text","text":"protocol-conformance isolation"}],"overridingTitle":"protocol-conformance isolation"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","level":2,"anchor":"CObjective-C","text":"C\/Objective-C"},{"type":"paragraph","inlineContent":[{"text":"You can expose Swift concurrency support for your C and Objective-C APIs","type":"text"},{"text":" ","type":"text"},{"text":"using annotations.","type":"text"},{"text":" ","type":"text"},{"text":"This is made possible by Clang’s","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/clang.llvm.org\/docs\/AttributeReference.html#customizing-swift-import","isActive":true},{"text":":","type":"text"}]},{"syntax":null,"type":"codeListing","code":["__attribute__((swift_attr(“@Sendable”)))","__attribute__((swift_attr(“@_nonSendable”)))","__attribute__((swift_attr(\"nonisolated\")))","__attribute__((swift_attr(\"@UIActor\")))","","__attribute__((swift_async(none)))","__attribute__((swift_async(not_swift_private, COMPLETION_BLOCK_INDEX))","__attribute__((swift_async(swift_private, COMPLETION_BLOCK_INDEX)))","__attribute__((__swift_async_name__(NAME)))","__attribute__((swift_async_error(none)))","__attribute__((__swift_attr__(\"@_unavailableFromAsync(message: \\\"\" msg \"\\\")\")))"]},{"type":"paragraph","inlineContent":[{"text":"When working with a project that can import Foundation, the following","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"annotation macros are available in "},{"code":"NSObjCRuntime.h","type":"codeVoice"},{"type":"text","text":":"}]},{"code":["NS_SWIFT_SENDABLE","NS_SWIFT_NONSENDABLE","NS_SWIFT_NONISOLATED","NS_SWIFT_UI_ACTOR","","NS_SWIFT_DISABLE_ASYNC","NS_SWIFT_ASYNC(COMPLETION_BLOCK_INDEX)","NS_REFINED_FOR_SWIFT_ASYNC(COMPLETION_BLOCK_INDEX)","NS_SWIFT_ASYNC_NAME","NS_SWIFT_ASYNC_NOTHROW","NS_SWIFT_UNAVAILABLE_FROM_ASYNC(msg)"],"type":"codeListing","syntax":null},{"type":"heading","level":3,"anchor":"Dealing-missing-isolation-annotations-in-Objective-C-libraries","text":"Dealing missing isolation annotations in Objective-C libraries"},{"inlineContent":[{"text":"While the SDKs and other Objective-C libraries make progress in adopting Swift concurrency,","type":"text"},{"type":"text","text":" "},{"text":"they will often go through the exercise of codifying contracts which were only explained in","type":"text"},{"type":"text","text":" "},{"text":"documentation. For example, before Swift concurrency, APIs frequently had to document their","type":"text"},{"type":"text","text":" "},{"text":"threading behavior with comments like “this will always be called on the main thread”.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift concurrency enables us to turn these code comments, into compiler and runtime"},{"type":"text","text":" "},{"type":"text","text":"enforced isolation checks, that Swift will then verify when you adopt such APIs."}]},{"inlineContent":[{"type":"text","text":"For example, the fictional "},{"type":"codeVoice","code":"NSJetPack"},{"type":"text","text":" protocol generally invokes all of its delegate methods"},{"type":"text","text":" "},{"type":"text","text":"on the main thread, and therefore has now become MainActor-isolated."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library author can mark as MainActor isolated using the "},{"code":"NS_SWIFT_UI_ACTOR","type":"codeVoice"},{"type":"text","text":" attribute,"},{"text":" ","type":"text"},{"text":"which is equivalent to annotating a type using ","type":"text"},{"code":"@MainActor","type":"codeVoice"},{"type":"text","text":" in Swift:"}]},{"type":"codeListing","syntax":"swift","code":["NS_SWIFT_UI_ACTOR","@protocol NSJetPack \/\/ fictional protocol","  \/\/ ...","@end"]},{"type":"paragraph","inlineContent":[{"text":"Thanks to this, all member methods of this protocol inherit the ","type":"text"},{"type":"codeVoice","code":"@MainActor"},{"text":" isolation,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and for most methods this is correct."}]},{"inlineContent":[{"text":"However, in this example, let us consider a method which was previously documented as follows:","type":"text"}],"type":"paragraph"},{"syntax":"objc","code":["NS_SWIFT_UI_ACTOR \/\/ SDK author annotated using MainActor in recent SDK audit","@protocol NSJetPack \/\/ fictional protocol","\/* Return YES if this jetpack supports flying at really high altitude!"," "," JetPackKit invokes this method at a variety of times, and not always on the main thread. For example, ...","*\/","@property(readonly) BOOL supportsHighAltitude;","","@end"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This method’s isolation was accidentally inferred as "},{"type":"codeVoice","code":"@MainActor"},{"text":", because of the annotation on the enclosing type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Although it has specifically documented different a threading strategy - it may or may not"},{"type":"text","text":" "},{"type":"text","text":"be invoked on the main actor - it missed to annotate these semantics on the method."}]},{"inlineContent":[{"text":"This is an annotation problem in the fictional JetPackKit library.","type":"text"},{"type":"text","text":" "},{"text":"Specifically, it is missing a ","type":"text"},{"code":"nonisolated","type":"codeVoice"},{"text":" annotation on the method,","type":"text"},{"type":"text","text":" "},{"text":"which would inform Swift about the correct and expected execution semantics.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift code adopting this library may look like this:"}]},{"syntax":"swift","type":"codeListing","code":["@MainActor","final class MyJetPack: NSJetPack {","  override class var supportsHighAltitude: Bool { \/\/ runtime crash in Swift 6 mode","    true","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The above code will crash with a runtime check, which aims to ensure we are actually"},{"text":" ","type":"text"},{"type":"text","text":"executing on the main actor as we’re crossing from objective-c’s non-swift-concurrency"},{"text":" ","type":"text"},{"text":"land into Swift.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"It is a Swift 6 feature to detect such issues automatically and crash at runtime","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when such expectations are violated. Leaving such issues un-diagnosed, could lead"},{"type":"text","text":" "},{"type":"text","text":"to actual hard-to-detect data races, and undermine Swift 6’s promise about data-race safety."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Such failure would include a similar backtrace to this:"}]},{"type":"codeListing","code":["* thread #5, queue = 'com.apple.root.default-qos', stop reason = EXC_BREAKPOINT (code=1, subcode=0x1004f8a5c)","  * frame #0: 0x00000001004..... libdispatch.dylib`_dispatch_assert_queue_fail + 120","    frame #1: 0x00000001004..... libdispatch.dylib`dispatch_assert_queue + 196","    frame #2: 0x0000000275b..... libswift_Concurrency.dylib`swift_task_isCurrentExecutorImpl(swift::SerialExecutorRef) + 280","    frame #3: 0x0000000275b..... libswift_Concurrency.dylib`Swift._checkExpectedExecutor(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _executor: Builtin.Executor) -> () + 60","    frame #4: 0x00000001089..... MyApp.debug.dylib`@objc static JetPack.supportsHighAltitude.getter at <compiler-generated>:0","    ...","    frame #10: 0x00000001005..... libdispatch.dylib`_dispatch_root_queue_drain + 404","    frame #11: 0x00000001005..... libdispatch.dylib`_dispatch_worker_thread2 + 188","    frame #12: 0x00000001005..... libsystem_pthread.dylib`_pthread_wqthread + 228"],"syntax":null},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When encountering such issue, and by investigating the documentation and API annotations you determine something"},{"type":"text","text":" "},{"type":"text","text":"was incorrectly annotated, the best way to resolve the root cause of the problem is to report the issue back to the"},{"text":" ","type":"text"},{"type":"text","text":"library maintainer."}]}],"style":"note","type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As you can see, the runtime injected an executor check into the call, and the dispatch queue assertion (of it running on the MainActor),"},{"text":" ","type":"text"},{"text":"has failed. This prevents sneaky and hard to debug data-races.","type":"text"}]},{"inlineContent":[{"type":"text","text":"The correct long-term solution to this issue is the library fixing the method’s annotation, by marking it as "},{"code":"nonisolated","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"objc","code":["\/\/ Solution in the library providing the API:","@property(readonly) BOOL supportsHighAltitude NS_SWIFT_NONISOLATED;"],"type":"codeListing"},{"inlineContent":[{"text":"Until the library fixes its annotation issue, you are able to witness the method using a correctly ","type":"text"},{"type":"codeVoice","code":"nonisolated"},{"type":"text","text":" method, like this:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Solution in adopting client code, wishing to run in Swift 6 mode:","@MainActor","final class MyJetPack: NSJetPack {","  \/\/ Correct","  override nonisolated class var readyForTakeoff: Bool {","    true","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"This way Swift knows not to check for the not-correct assumption that the method requires main actor isolation.","type":"text"}]},{"text":"Dispatch","level":2,"type":"heading","anchor":"Dispatch"},{"type":"paragraph","inlineContent":[{"text":"Some patterns which you may be used to from Dispatch or other concurrency libraries","type":"text"},{"type":"text","text":" "},{"text":"may need to be re-shaped in order to fit the world of Swift’s structured concurrency model.","type":"text"}]},{"text":"Limiting concurrency using Task Groups","level":3,"anchor":"Limiting-concurrency-using-Task-Groups","type":"heading"},{"inlineContent":[{"type":"text","text":"Sometimes you may find yourself with a large list of work to be processed."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"While it is possible to just enqueue “all” those work items to a task group like this:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ WARNING: Potentially wasteful -- perhaps this creates thousands of tasks concurrently (?!)","","let lotsOfWork: [Work] = ...","await withTaskGroup(of: Something.self) { group in","  for work in lotsOfWork {","    \/\/ WARNING: If this is thousands of items, we may end up creating a lot of tasks","    \/\/  which won't get to be executed until much later, as we have a global limit on","    \/\/  the amount of concurrently running tasks - depending on the core count of the system,","    \/\/  and the default global executor's configuration.","    group.addTask {","      await work.work()","    }","  }","","  for await result in group {","    process(result) \/\/ process the result somehow, depends on your needs","  }","}"]},{"inlineContent":[{"type":"text","text":"If you suspect you may be dealing with hundreds or thousands of items, it may be wasteful to enqueue them all immediately."},{"text":" ","type":"text"},{"type":"text","text":"Creating a task (in "},{"code":"addTask","type":"codeVoice"},{"text":") needs to allocate some memory for the task in order to suspend and execute,","type":"text"},{"type":"text","text":" "},{"text":"while this amount of memory isn’t too large, it can become significant if creating thousands of tasks which don’t get to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"execute immediately but are just waiting until the executor gets to run them."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When faced with such a situation, it may be beneficial to manually throttle the number of concurrently added tasks to the task group, as follows:"}]},{"syntax":"swift","code":["let lotsOfWork: [Work] = ... ","let maxConcurrentWorkTasks = min(lotsOfWork.count, 10)","assert(maxConcurrentWorkTasks > 0)","","await withTaskGroup(of: Something.self) { group in","    var submittedWork = 0","    for _ in 0..<maxConcurrentWorkTasks {","        group.addTask { \/\/ or 'addTaskUnlessCancelled'","            await lotsOfWork[submittedWork].work() ","        }","        submittedWork += 1","    }","    ","    for await result in group {","        process(result) \/\/ process the result somehow, depends on your needs","    ","        \/\/ Every time we get a result back, check if there's more work we should submit and do so","        if submittedWork < lotsOfWork.count, ","           let remainingWorkItem = lotsOfWork[submittedWork] {","            group.addTask { \/\/ or 'addTaskUnlessCancelled'","                await remainingWorkItem.work() ","            }  ","            submittedWork += 1","        }","    }","}"],"type":"codeListing"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/org.swift.migration.6\/documentation\/MigrationGuide"]]},"references":{"commonproblems#Crossing-Isolation-Boundaries":{"url":"commonproblems#Crossing-Isolation-Boundaries","title":"Crossing Isolation Boundaries","type":"link","identifier":"commonproblems#Crossing-Isolation-Boundaries","titleInlineContent":[{"type":"text","text":"Crossing Isolation Boundaries"}]},"doc://org.swift.migration.6/documentation/MigrationGuide":{"role":"collection","abstract":[],"type":"topic","title":"Migrating to Swift 6","identifier":"doc:\/\/org.swift.migration.6\/documentation\/MigrationGuide","kind":"article","url":"\/documentation\/migrationguide"},"https://clang.llvm.org/docs/AttributeReference.html#customizing-swift-import":{"titleInlineContent":[{"type":"text","text":"concurrency-specific annotations"}],"type":"link","url":"https:\/\/clang.llvm.org\/docs\/AttributeReference.html#customizing-swift-import","title":"concurrency-specific annotations","identifier":"https:\/\/clang.llvm.org\/docs\/AttributeReference.html#customizing-swift-import"},"https://developer.apple.com/documentation/swift/concurrency#continuations":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/concurrency#continuations","title":"suite of standard library APIs","type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/concurrency#continuations","titleInlineContent":[{"type":"text","text":"suite of standard library"},{"type":"text","text":" "},{"text":"APIs","type":"text"}]}}}