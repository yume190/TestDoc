{"sections":[],"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"text":"編譯器提供的數據隔離保證影響所有 Swift 代碼。這意味著，完整的並發檢查可能會暴露潛在的問題，即使是那些不直接使用任何並發語言特性的 Swift 5 代碼也不例外。並且，在 Swift 6 語言模式啟用時，這些潛在問題有可能變成錯誤。","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"啟用完整檢查後，許多項目可能會出現大量警告和錯誤。不要感到不知所措！大多數問題可以追溯到一小部分根本原因。而這些原因通常是由常見的模式引起的，這些模式不僅易於修復，還能非常有助於理解 Swift 的數據隔離模型。","type":"text"}]},{"type":"heading","text":"不安全的全局和靜態變量","level":2,"anchor":"不安全的全局和靜態變量"},{"type":"paragraph","inlineContent":[{"type":"text","text":"全局狀態，包括靜態變量，可以在程序的任何地方訪問。這種可見性使它們特別容易受到並發訪問的影響。在數據競爭安全性之前，全局變量模式依賴於程序員謹慎地訪問全局狀態，以避免數據競爭，而不依賴於編譯器的幫助。"}]},{"style":"experiment","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"這些代碼示例以包的形式提供。請在 "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-migration-guide\/blob\/main\/Sources\/Examples\/Globals.swift"},{"type":"text","text":" 中自行試用。"}]}],"name":"Experiment"},{"level":3,"text":"可發送的類型","type":"heading","anchor":"可發送的類型"},{"syntax":"swift","type":"codeListing","code":["var supportedStyleCount = 42"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"這裡，我們定義了一個全局變量。該全局變量既是非隔離的又是可變的，並且可以從任何隔離域訪問。在 Swift 6 模式中編譯上述代碼會產生錯誤消息："}]},{"type":"codeListing","syntax":"swift","code":["1 | var supportedStyleCount = 42","  |              |- 錯誤：全局變量 'supportedStyleCount' 不是並發安全的，因為它是非隔離的全局共享可變狀態","  |              |- 註釋：將 'supportedStyleCount' 轉換為 'let' 常量以使共享狀態不可變","  |              |- 註釋：如果 'supportedStyleCount' 僅從主線程訪問，則將其限制為主 actor","  |              |- 註釋：如果所有訪問都受外部同步機制保護，則可以不安全地標記 'supportedStyleCount' 為並發安全","2 |"]},{"type":"paragraph","inlineContent":[{"text":"兩個具有不同隔離域的函數訪問此變量會導致數據競爭。在下面的代碼中，","type":"text"},{"code":"printSupportedStyles()","type":"codeVoice"},{"text":" 可以在主 actor 上運行，並且與從另一個隔離域調用的 ","type":"text"},{"type":"codeVoice","code":"addNewStyle()"},{"text":" 並發運行：","type":"text"}]},{"type":"codeListing","code":["@MainActor","func printSupportedStyles() {","    print(\"Supported styles: \", supportedStyleCount)","}","","func addNewStyle() {","    let style = Style()","","    supportedStyleCount += 1","","    storeStyle(style)","}"],"syntax":"swift"},{"inlineContent":[{"text":"解決這個問題的一種方法是改變變量的隔離。","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@MainActor","var supportedStyleCount = 42"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"變量保持可變，但已隔離到全局 actor。所有訪問現在只能在一個隔離域中進行，並且在 "},{"type":"codeVoice","code":"addNewStyle"},{"type":"text","text":" 中的同步訪問在編譯時無效。"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"如果變量是常量且從未被修改，一個簡單的解決方案是將其表達為常量。通過將 "},{"type":"codeVoice","code":"var"},{"type":"text","text":" 更改為 "},{"code":"let","type":"codeVoice"},{"type":"text","text":"，編譯器可以靜態禁止修改，保證安全的只讀訪問。"}]},{"code":["let supportedStyleCount = 42"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"如果存在一個同步機制以保護該變量，並且這種機制對編譯器是不可見的，可以使用 "},{"type":"codeVoice","code":"nonisolated(unsafe)"},{"type":"text","text":" 關鍵字禁用所有隔離檢查："}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/\/ 該值僅在持有 `styleLock` 時訪問。","nonisolated(unsafe) var supportedStyleCount = 42"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"僅當你仔細保護所有對變量的訪問並使用外部同步機制（例如鎖或調度隊列）時，才使用 "},{"type":"codeVoice","code":"nonisolated(unsafe)"},{"type":"text","text":"。"}]},{"type":"heading","text":"非可發送類型","anchor":"非可發送類型","level":3},{"inlineContent":[{"type":"text","text":"在上述示例中，變量是 "},{"type":"codeVoice","code":"Int"},{"text":"，一個本質上是 ","type":"text"},{"type":"codeVoice","code":"Sendable"},{"text":" 的值類型。全局引用類型提出了額外的挑戰，因為它們通常不是 ","type":"text"},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":"。"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["class WindowStyler {","    var background: ColorComponents","","    static let defaultStyler = WindowStyler()","}"]},{"inlineContent":[{"text":"這個 ","type":"text"},{"type":"codeVoice","code":"static let"},{"text":" 聲明的問題與變量的可變性無關。問題是 ","type":"text"},{"type":"codeVoice","code":"WindowStyler"},{"text":" 是一個非 ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"type":"text","text":" 類型，這使得其內部狀態在不同隔離域之間共享不安全。"}],"type":"paragraph"},{"type":"codeListing","code":["func resetDefaultStyle() {","    WindowStyler.defaultStyler.background = ColorComponents(red: 1.0, green: 1.0, blue: 1.0)","}","","@MainActor","class StyleStore {","    var stylers: [WindowStyler]","","    func hasDefaultBackground() -> Bool {","        stylers.contains { $0.background == WindowStyler.defaultStyler.background }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"這裡，我們看到兩個函數可以並發地訪問 ","type":"text"},{"type":"codeVoice","code":"WindowStyler.defaultStyler"},{"type":"text","text":" 的內部狀態。編譯器僅允許使用 "},{"code":"Sendable","type":"codeVoice"},{"text":" 類型進行這種跨隔離訪問。一種解決方案是將變量隔離到單個域使用全局 actor，但也可以考慮直接添加 ","type":"text"},{"type":"codeVoice","code":"Sendable"},{"text":" 遵從性。","type":"text"}]},{"anchor":"協議遵從性隔離不匹配","type":"heading","level":2,"text":"協議遵從性隔離不匹配"},{"type":"paragraph","inlineContent":[{"text":"協議定義了實現類型必須滿足的要求。Swift 確保協議的客戶端可以以尊重數據隔離的方式與其方法和屬性交互。為此，協議本身及其要求必須指定靜態隔離。這可能會導致協議的聲明和遵從類型之間的隔離不匹配。","type":"text"}]},{"inlineContent":[{"text":"這類問題有很多可能的解決方案，但它們通常涉及權衡。選擇合適的方法首先需要理解為什麼會出現不匹配。","type":"text"}],"type":"paragraph"},{"name":"Experiment","content":[{"inlineContent":[{"type":"text","text":"這些代碼示例以包的形式提供。請在 "},{"identifier":"https:\/\/github.com\/apple\/swift-migration-guide\/blob\/main\/Sources\/Examples\/ConformanceMismatches.swift","type":"reference","isActive":true},{"type":"text","text":" 中自行試用。"}],"type":"paragraph"}],"type":"aside","style":"experiment"},{"type":"heading","anchor":"未明確指定的協議","level":3,"text":"未明確指定的協議"},{"inlineContent":[{"text":"這種問題最常見的形式是協議沒有明確的隔離。在這種情況下，與所有其他聲明一樣，這意味著非隔離。非隔離協議要求可以從任何隔離域中的泛型代碼調用。如果要求是同步的，那麼實現類型的實現訪問 actor 隔離狀態是無效的：","type":"text"}],"type":"paragraph"},{"code":["protocol Styler {","    func applyStyle()","}","","@MainActor","class WindowStyler: Styler {","    func applyStyle() {","        \/\/ 訪問主 actor 隔離狀態","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"上述代碼在 Swift 6 模式下會產生以下錯誤：","type":"text"}]},{"type":"codeListing","syntax":"swift","code":[" 5 | @MainActor"," 6 | class WindowStyler: Styler {"," 7 |     func applyStyle() {","   |          |- 錯誤：主 actor 隔離實例方法 'applyStyle()' 無法用於滿足非隔離協議要求","   |          `- 註釋：將 'applyStyle()' 標記為 'nonisolated' 以使此實例方法不隔離到 actor"," 8 |         \/\/ 訪問主 actor 隔離狀態"," 9 |     }"]},{"inlineContent":[{"text":"協議可能應該隔離，但尚未更新以反映這一點。如果實現類型首先被遷移以添加正確的隔離，就會出現不匹配。","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ 這實際上僅在主 actor 類型中有意義，但尚未更新以反映這一點。","protocol Styler {","    func applyStyle()","}","","\/\/ 一個實現類型，現在正確隔離，暴露了不匹配。","@MainActor","class WindowStyler: Styler {","}"],"type":"codeListing"},{"text":"添加隔離","type":"heading","level":4,"anchor":"添加隔離"},{"type":"paragraph","inlineContent":[{"type":"text","text":"如果協議要求總是從主 actor 調用，添加 "},{"code":"@MainActor","type":"codeVoice"},{"text":" 是最好的解決方案。","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"有兩種方法可以將協議要求隔離到主 actor："}]},{"code":["\/\/ 整個協議","@MainActor","protocol Styler {","    func applyStyle()","}","","\/\/ 每個要求","protocol Styler {","    @MainActor","    func applyStyle()","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"使用全局 actor 屬性標記協議意味著全局 actor 隔離適用於所有協議要求和擴展方法。當遵從項未在擴展中聲明時，還會推斷全局 actor 遵從性。","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"每個要求的隔離對 actor 隔離推斷影響較小，因為推斷僅適用於該要求的實現。它不會影響協議擴展或實現類型中其他方法的推斷隔離。如果實現類型不需要綁定到相同的全局 actor，應優先使用這種方法。","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"無論哪種方式，更改協議的隔離會影響實現類型的隔離，並且可能對使用該協議的泛型代碼施加限制。你可以使用 "},{"code":"@preconcurrency","type":"codeVoice"},{"text":" 分階段處理由於添加全局 actor 隔離引起的診斷：","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@preconcurrency @MainActor","protocol Styler {","    func applyStyle()","}"]},{"level":4,"text":"異步要求","type":"heading","anchor":"異步要求"},{"type":"paragraph","inlineContent":[{"type":"text","text":"對於實現同步協議要求的方法，方法的隔離必須完全匹配要求的隔離，或者方法必須是 "},{"type":"codeVoice","code":"nonisolated"},{"text":"，這意味著它可以從任何隔離域調用而不會有數據競爭風險。使要求異步可以在實現類型的隔離上提供更多的靈活性。","type":"text"}]},{"code":["protocol Styler {","    func applyStyle() async","}","","@MainActor","class WindowStyler: Styler {","    func applyStyle() async {","        \/\/ 訪問主 actor 隔離狀態","    }","}","異步要求將允許從其他 actor 調用，並允許不同的實現類型在不同的隔離域中提供實現。","","總之，識別並解決這些常見的編譯器錯誤需要理解 Swift 並發模型及其數據隔離保證。通過改變變量的隔離，確保協議和其實現的一致性，並正確地處理不同隔離域之間的數據共享，可以有效地解決大多數問題。"],"type":"codeListing","syntax":"swift"}]}],"abstract":[{"type":"text","text":"識別、理解和解決在使用 Swift 並發性時常見的問題。"}],"kind":"article","hierarchy":{"paths":[["doc:\/\/org.swift.migration.6\/documentation\/MigrationGuide"]]},"schemaVersion":{"patch":0,"major":0,"minor":3},"identifier":{"url":"doc:\/\/org.swift.migration.6\/documentation\/Swift-6-Concurrency-Migration-Guide\/CommonProblemsZh","interfaceLanguage":"swift"},"metadata":{"title":"常見編譯器錯誤"},"references":{"https://github.com/apple/swift-migration-guide/blob/main/Sources/Examples/Globals.swift":{"title":"Globals.swift","titleInlineContent":[{"text":"Globals.swift","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift-migration-guide\/blob\/main\/Sources\/Examples\/Globals.swift","type":"link","url":"https:\/\/github.com\/apple\/swift-migration-guide\/blob\/main\/Sources\/Examples\/Globals.swift"},"https://github.com/apple/swift-migration-guide/blob/main/Sources/Examples/ConformanceMismatches.swift":{"title":"ConformanceMismatches.swift","titleInlineContent":[{"type":"text","text":"ConformanceMismatches.swift"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-migration-guide\/blob\/main\/Sources\/Examples\/ConformanceMismatches.swift","url":"https:\/\/github.com\/apple\/swift-migration-guide\/blob\/main\/Sources\/Examples\/ConformanceMismatches.swift"},"doc://org.swift.migration.6/documentation/MigrationGuide":{"role":"collection","abstract":[],"type":"topic","title":"Migrating to Swift 6","identifier":"doc:\/\/org.swift.migration.6\/documentation\/MigrationGuide","kind":"article","url":"\/documentation\/migrationguide"}}}